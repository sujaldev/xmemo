<!DOCTYPE html>
<html>
<head>
	<title>Xmemo ~ Questions View</title>
	<meta charset="UTF-8">
    {% load static %}
	<link rel="shortcut icon" href="{% static 'img/favicon.ico' %}">
	<link id="theme_css" rel="stylesheet" type="text/css" href="{% static 'css/' %}{{ theme }}-theme.css">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* PrismJS 1.23.0
		https://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript+markdown+python */
		/**
		 * prism.js tomorrow night eighties for JavaScript, CoffeeScript, CSS and HTML
		 * Based on https://github.com/chriskempson/tomorrow-theme
		 * @author Rose Pritchard
		 */

		code[class*="language-"],
		pre[class*="language-"] {
			color: #ccc;
			background: none;
			font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
			font-size: 1em;
			text-align: left;
			white-space: pre;
			word-spacing: normal;
			word-break: normal;
			word-wrap: normal;
			line-height: 1.5;

			-moz-tab-size: 4;
			-o-tab-size: 4;
			tab-size: 4;

			-webkit-hyphens: none;
			-moz-hyphens: none;
			-ms-hyphens: none;
			hyphens: none;

		}

		/* Code blocks */
		pre[class*="language-"] {
			padding: 1em;
			margin: .5em 0;
			overflow: auto;
		}

		:not(pre) > code[class*="language-"],
		pre[class*="language-"] {
			background: #2d2d2d;
		}

		/* Inline code */
		:not(pre) > code[class*="language-"] {
			padding: .1em;
			border-radius: .3em;
			white-space: normal;
		}

		.token.comment,
		.token.block-comment,
		.token.prolog,
		.token.doctype,
		.token.cdata {
			color: #999;
		}

		.token.punctuation {
			color: #ccc;
		}

		.token.tag,
		.token.attr-name,
		.token.namespace,
		.token.deleted {
			color: #e2777a;
		}

		.token.function-name {
			color: #6196cc;
		}

		.token.boolean,
		.token.number,
		.token.function {
			color: #f08d49;
		}

		.token.property,
		.token.class-name,
		.token.constant,
		.token.symbol {
			color: #f8c555;
		}

		.token.selector,
		.token.important,
		.token.atrule,
		.token.keyword,
		.token.builtin {
			color: #cc99cd;
		}

		.token.string,
		.token.char,
		.token.attr-value,
		.token.regex,
		.token.variable {
			color: #7ec699;
		}

		.token.operator,
		.token.entity,
		.token.url {
			color: #67cdcc;
		}

		.token.important,
		.token.bold {
			font-weight: bold;
		}
		.token.italic {
			font-style: italic;
		}

		.token.entity {
			cursor: help;
		}

		.token.inserted {
			color: green;
		}
    </style>
    <style>
		@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,500;0,600;1,700&display=swap');

	    html {
				overflow-x: hidden;
				background: var(--page-background);
				transition: 0.5s ease-out;
			}


		*{
			margin: 0;
			padding: 0;
			box-sizing: border-box;
			font-family: 'Roboto Mono', monospace;
			-webkit-tap-highlight-color: transparent;
		}

		.githublogo{
			fill: var(--github-color);
		}


		a{
			color: var(--link-color);
		}



		/* MAIN CODE BEGINS HERE*/


		.navbar{
			/*Flex container properties*/
			display: flex;
			flex-wrap: nowrap;
			justify-content: space-between;
			align-items: center;

			/*Container aesthetics*/
			height: 70px;

			font-family: 'Montserrat', sans-serif; /* font */
			font-size: 20px;
			font-weight: 900;

			color: var(--title-color); /* colors */
			background: var(--nav-color);

			box-shadow: 0 0 5px -1px rgba(0,0,0,0.2);
		}

		.title{
			flex: 2;
			text-align: left;
			margin-left: 5%;
			cursor: pointer;
		}


		.logo{
			flex: 1;
			text-align: right;
			margin-right: 5%;
			cursor: pointer;
		}

		.ham-menu{
			display: none;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			flex-wrap: nowrap;


			position: fixed;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
			z-index: 1;
			font-weight: 500;
			background: var(--ham-menu-background);
		}

		.ham-active {
			display: flex;
			opacity: 0;
			animation: appear 0.75s ease both;
		}

		@keyframes appear{
			to{opacity: 1;}
		}
		.sub {
			margin-bottom: 20px;
			width: 100px;
			padding: 10px;

			text-align: center;

			border: 2px solid var(--ham-menu-border);
			border-radius: 7px;
		}

		.sub a{
			text-decoration: none;
			color: var(--ham-menu-color);

		}

		.close-ham{
			cursor: pointer;
		}


		.footer{
			display: flex;
			flex-wrap: nowrap;
			flex-direction: column;
			justify-content: center;
			align-items: center;


			position: absolute;
			padding: 50px 0 50px 0;
			height: 120px;
			width: 100%;
			margin-top: 10vh;
			font-family: 'Roboto Mono', monospace;
			font-weight: 500;
			color: var(--footer-color);
			background: var(--footer-background);
		}


		.contrib{
			padding-top:20px;
		}


		.noselect {
			user-select: none;
		}

		.main-container{
			position: relative;
			left: 5%;
			width: 90%;
			min-height: 100vh;
			background: var(--page-background);
			border: 1px solid var(--main-border);
			border-radius: 6px;
			margin: 50px 0 15px 0;
			padding-bottom: 100px;
		}


		.sub-container{
			position: relative;
			left: 5%;
			width: 90%;
			height: auto;
			background: var(--page-background);
			border: 1px solid var(--main-border);
			border-radius: 6px;
			margin: 100px 0 15px 0;
			padding-bottom: 100px;
		}

		.heading {
			position: relative;
			top: 50px;
			left: 5%;
			width: 90%;
			padding: 30px;
		}

		.heading p{
			font-size: 25px;
			font-weight: 700;
			color: var(--heading-color);
		}

		.heading div{
			position: relative;
			margin-top: 15px;
			top: 100%;
			left: 0%;
			width: 100%;
			height: 2px;
			background: var(--main-border);
		}

		.sub-heading {
			position: relative;
			top: 50px;
			left: 10%;
			width: 80%;
			padding: 30px;
		}

	    .sub-heading p{
	        font-size: 20px;
	        font-weight: 600;
	        color: var(--heading-color);
	    }

	    .sub-heading div{
	        position: relative;
	        margin-top: 15px;
	        top: 100%;
	        left: 0%;
	        width: 100%;
	        height: 2px;
	        background: var(--main-border);
	    }

	    .main-text {
	        position: relative;
	        top: 40px;
	        left: 5%;
	        width: 90%;
	        padding: 10px 30px 10px 30px;
	        font-weight: 300;
	        font-size: 15px;
	        color: var(--text-color);
	    }

	    .main-text bold{
	        font-weight: 500;
	    }

	    .sub-text {
	        position: relative;
	        top: 40px;
	        left: 10%;
	        width: 80%;
	        padding: 10px 30px 10px 30px;
	        font-weight: 300;
	        font-size: 14px;
	        color: var(--text-color);
	    }

	    .sub-text bold{
	        font-weight: 500;
	    }

	    .inline-btn{
	        -webkit-tap-highlight-color: transparent;
	        user-select: none;
	        display: inline-block;
	        position: relative;
	        margin: 0 10px 0 10px;
	        padding: 10px 20px 10px 20px;
	        background: var(--button-background);
	        border: 1px solid var(--main-border);
	        border-radius: 5px;
	        cursor: pointer;
	        transition: 0.1s ease;
	        text-decoration: none;
	        color: var(--button-color);
	        font-weight: 500;
	        font-size: 15px;
	    }

	    .inline-btn:active{
	        background: var(--ham-menu-selected-border);
	        color: white;
	    }


	    .btn{
	        -webkit-tap-highlight-color: transparent;
	        user-select: none;
	        display: table;
	        position: relative;
	        padding: 10px 20px 10px 20px;
	        background: var(--button-background);
	        border: 1px solid var(--main-border);
	        border-radius: 5px;
	        cursor: pointer;
	        transition: 0.1s ease;
	        text-decoration: none;
	        color: var(--button-color);
	        font-weight: 500;
	        font-size: 15px;
	        margin: 20px 10px 20px 10px;
	    }


	    .input{
	        padding: 20px;
	        position: relative;
	        left: 5%;
	        min-width: 40%;
	        height: 30px;
	        border: 1px solid var(--main-border);
	        outline: none;
	        margin-top: 5%;
	        font-weight: 300;
	        font-size: 15px;
	        color: var(--text-color);
	        background: var(--search-background);
	    }


	    .search{
	        display: inline-flex;
	        align-items: stretch;
	        align-content: flex-start;
	        max-width: 80%;
	    }


	    .search input{
	        margin: 0;
	    }


	    .table-entry{
	        display: inline-block;
	        position: relative;
	        left: 5%;
	        min-width: 30%;
	        max-width: 90%;
	        padding: 10px 25px 10px 25px;
	        background: var(--table-entry);
	        border: 1px solid var(--table-entry-border);
	        border-radius: 5px;
	        font-size: 18px;
	        font-weight: 500;
	        -webkit-tap-highlight-color: transparent;
	    }

	    .table-entry a{
	        color: var(--text-color);
	        text-decoration: none;
	    }

	    .question {
	        position: relative;
	        top: 50px;
	        left: 5%;
	        width: 90%;
	        padding: 30px;
	        font-size: 15px;
	    }

	    .question p{
	        font-size: 20px;
	        font-weight: 700;
	        color: var(--heading-color);
	    }

	    .question div{
	        position: relative;
	        margin-top: 15px;
	        top: 100%;
	        left: 0%;
	        width: 100%;
	        height: 2px;
	        background: var(--main-border);
	    }


	    .code-block {
	        position: relative;
	        left: 5%;
	        width: 90%;
	        background: var(--code-block-background) !important;
	        font-size: 15px !important;
	    }


	    .validity-check{
	        display: flex;
	        justify-content: space-between;
	        position: relative;
	        top: 50px;
	        left: 5%;
	        width: 90%;
	        height: auto;
	        margin-bottom: 30px;
	    }

	    .validity-check .wrong:active{
	        background: var(--wrong-button-hover)
	    }


	    .major-line-break{
	        position: relative;
	        top: 50px;
	        left: 5%;
	        width: 90%;
	        height: 3px;
	        background: var(--major-line-break);
	        margin-bottom: 30px;
	    }

	    .minor-line-break{
	        position: relative;
	        top: 40px;
	        left: 5%;
	        width: 90%;
	        height: 2px;
	        background: var(--minor-line-break);
	        margin-bottom: 30px;
	    }
    </style>
</head>
<body>
	<header>
		<div class="navbar">
			<p class="title noselect">XMEMO</p>
			<div class="logo noselect">
				{% block sub_logo %}
					<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" x="0px" y="0px"
						 viewBox="0 0 144 144" style="enable-background:new 0 0 144 144;" xml:space="preserve">
					<style type="text/css">
						.cs0{fill:#0B5FAA;}
						.cs1{fill:#0D74E7;}
						.cs2{opacity:0.9;fill:url(#SVGID_1_);}
						.cs3{fill:#4B8BBE;}
						.cs4{fill:#FFE873;}
					</style>
					<polygon class="cs0" points="128.6,44.5 128.6,107.5 92.2,128.5 88.5,130.6 74,139 19.4,107.5 19.4,44.5 74,13 "/>
					<polygon class="cs1" points="20,42 20,102 72,132 124,102 124,42 72,12 "/>
					<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="44.9201" y1="61.4311" x2="181.9672" y2="169.0331">
						<stop  offset="0" style="stop-color:#000000;stop-opacity:0.3"/>
						<stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.5"/>
					</linearGradient>
					<path class="cs2" d="M128.6,72.7v34.8l-36.3,21L74,139L36.3,78.7l14.1-14.2l7.8,1.3L74,62.7c0,0,6.3-7.7,6.6-8.7
						c0.4-1.1-2-8.5-2.3-8.6c-0.2-0.1-3.8-1.7-6.1-2.8c0,0,1.6-1.8,5.6-5C82.8,33.7,111.4,59.9,128.6,72.7z"/>
					<g id="Py_logo">
						<g>
							<g>
								<path class="cs3" d="M84.2,69.8c5.7-2.6,6.5-22.2,3.2-28c-4.4-7.6-25.2-6-31.8-0.6c-0.8,2.7-0.7,7.6-0.6,11.6h20.8v1.6H54.9
									c0,0.1-9.2,0.1-9.2,0.1c-15.9,0-15.5,34.5,5.4,34.5c0,0,0.8-7.6,2.1-11.5C57.4,65.6,74.8,74,84.2,69.8z M62.5,49.7
									c-2.4,0-4.3-1.9-4.3-4.3c0-2.4,1.9-4.3,4.3-4.3c2.4,0,4.3,1.9,4.3,4.3C66.9,47.8,64.9,49.7,62.5,49.7z"/>
								<path class="cs4" d="M92.2,55.1c0,0-0.5,7.6-1.9,11.5c-4.2,11.8-21.6,3.4-31,7.6c-5.7,2.6-6.5,22.2-3.2,28
									c4.4,7.6,25.2,6,31.8,0.6c0.8-2.7,0.7-7.5,0.6-11.6H67.8v-1.6h20.8c0-0.1,10.2-0.1,10.2-0.1C113.4,89.6,114.7,55.1,92.2,55.1z
									 M80.2,93.5c2.4,0,4.3,1.9,4.3,4.3c0,2.4-1.9,4.3-4.3,4.3s-4.3-1.9-4.3-4.3C75.9,95.4,77.8,93.5,80.2,93.5z"/>
							</g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
					</g>
					</svg>
				{% endblock %}
			</div>
		</div>
		<div class="ham-menu">
			<div class="sub cs selected-subject">
				<a href="/">
					<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" x="0px" y="0px"
						 viewBox="0 0 144 144" style="enable-background:new 0 0 144 144;" xml:space="preserve">
					<style type="text/css">
						.cs0{fill:#0B5FAA;}
						.cs1{fill:#0D74E7;}
						.cs2{opacity:0.9;fill:url(#SVGID_1_);}
						.cs3{fill:#4B8BBE;}
						.cs4{fill:#FFE873;}
					</style>
					<polygon class="cs0" points="128.6,44.5 128.6,107.5 92.2,128.5 88.5,130.6 74,139 19.4,107.5 19.4,44.5 74,13 "/>
					<polygon class="cs1" points="20,42 20,102 72,132 124,102 124,42 72,12 "/>
					<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="44.9201" y1="61.4311" x2="181.9672" y2="169.0331">
						<stop  offset="0" style="stop-color:#000000;stop-opacity:0.3"/>
						<stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.5"/>
					</linearGradient>
					<path class="cs2" d="M128.6,72.7v34.8l-36.3,21L74,139L36.3,78.7l14.1-14.2l7.8,1.3L74,62.7c0,0,6.3-7.7,6.6-8.7
						c0.4-1.1-2-8.5-2.3-8.6c-0.2-0.1-3.8-1.7-6.1-2.8c0,0,1.6-1.8,5.6-5C82.8,33.7,111.4,59.9,128.6,72.7z"/>
					<g id="Py_logo">
						<g>
							<g>
								<path class="cs3" d="M84.2,69.8c5.7-2.6,6.5-22.2,3.2-28c-4.4-7.6-25.2-6-31.8-0.6c-0.8,2.7-0.7,7.6-0.6,11.6h20.8v1.6H54.9
									c0,0.1-9.2,0.1-9.2,0.1c-15.9,0-15.5,34.5,5.4,34.5c0,0,0.8-7.6,2.1-11.5C57.4,65.6,74.8,74,84.2,69.8z M62.5,49.7
									c-2.4,0-4.3-1.9-4.3-4.3c0-2.4,1.9-4.3,4.3-4.3c2.4,0,4.3,1.9,4.3,4.3C66.9,47.8,64.9,49.7,62.5,49.7z"/>
								<path class="cs4" d="M92.2,55.1c0,0-0.5,7.6-1.9,11.5c-4.2,11.8-21.6,3.4-31,7.6c-5.7,2.6-6.5,22.2-3.2,28
									c4.4,7.6,25.2,6,31.8,0.6c0.8-2.7,0.7-7.5,0.6-11.6H67.8v-1.6h20.8c0-0.1,10.2-0.1,10.2-0.1C113.4,89.6,114.7,55.1,92.2,55.1z
									 M80.2,93.5c2.4,0,4.3,1.9,4.3,4.3c0,2.4-1.9,4.3-4.3,4.3s-4.3-1.9-4.3-4.3C75.9,95.4,77.8,93.5,80.2,93.5z"/>
							</g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
						<g>
						</g>
					</g>
					</svg>
					Computer Science</a>
			</div>
			<div class="sub ph">
				<a href="/physics">
					<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" x="0px" y="0px"
						 viewBox="0 0 144 144" style="enable-background:new 0 0 144 144;" xml:space="preserve">
					<style type="text/css">
						.ph0{fill:#E06D17;}
						.ph1{fill:#FF7F14;}
						.ph2{opacity:0.9;fill:url(#SVGID_1_);}
						.ph3{fill:#FFFFFF;}
					</style>
					<polygon class="ph0" points="128.6,44.5 128.6,107.5 92.2,128.5 88.5,130.6 74,139 19.4,107.5 19.4,44.5 74,13 "/>
					<polygon class="ph1" points="20,42 20,102 72,132 124,102 124,42 72,12 "/>
					<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="39.9475" y1="57.6901" x2="186.0424" y2="172.3959">
						<stop  offset="0" style="stop-color:#000000;stop-opacity:0.3"/>
						<stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.5"/>
					</linearGradient>
					<path class="ph2" d="M128.6,72.7v34.8l-36.3,21L74,139L46.8,95.2l0-39.6l11.4,10.2l18.2,4c0,0,8.4-11.2,4.2-15.8
						c-0.8-0.8-2-8.5-2.3-8.6c-0.2-0.1,6.2-1.4,4-2.4l9,1L128.6,72.7z"/>
					<g>
						<path class="ph3" d="M99.3,60.3c0,13-9.9,21.1-25.5,21.1h-8.1v13.8H46.8v-56h27C89.4,39.2,99.3,47.4,99.3,60.3z M80.3,60.3
							c0-4.1-2.5-6.6-7.7-6.6h-6.9v13.1h6.9C77.8,66.9,80.3,64.4,80.3,60.3z"/>
					</g>
					</svg>
					Physics</a>
			</div>
			<div class="sub ch">
				<a href="/chemistry">
					<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" x="0px" y="0px"
	 				viewBox="0 0 144 144" style="enable-background:new 0 0 144 144;" xml:space="preserve">
					<style type="text/css">
						.ch0{fill:#E0B812;}
						.ch1{fill:#F1C40F;}
						.ch2{opacity:0.9;fill:url(#SVGID_1_);}
						.ch3{fill:#FFFFFF;}
					</style>
					<polygon class="ch0" points="128.6,44.5 128.6,107.5 92.2,128.5 88.5,130.6 74,139 19.4,107.5 19.4,44.5 74,13 "/>
					<polygon class="ch1" points="20,42 20,102 72,132 124,102 124,42 72,12 "/>
					<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="49.2822" y1="64.0999" x2="178.9429" y2="165.9024">
						<stop  offset="0" style="stop-color:#000000;stop-opacity:0.3"/>
						<stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.5"/>
					</linearGradient>
					<path class="ch2" d="M128.6,72.7v34.8l-36.3,21L74,139L48.3,81.9l6.6-4.1l3.3-12l6.1-15c0,0,13.5,0.4,9.3-4.2
						c-0.8-0.8,5-1.1,4.7-1.2c-0.2-0.1,6.2-1.4,4-2.4l18.6,6.1L128.6,72.7z"/>
					<g>
						<path class="ch3" d="M44.6,67.2c0-17.2,13.2-29.3,31.2-29.3c11,0,19.6,4,25.1,11.2L89,59.8c-3.3-4.2-7.2-6.6-12.2-6.6
							c-7.8,0-13.1,5.4-13.1,14s5.3,14,13.1,14c5,0,9-2.4,12.2-6.6l11.9,10.6c-5.5,7.2-14.2,11.2-25.1,11.2
							C57.8,96.5,44.6,84.4,44.6,67.2z"/>
					</g>
					</svg>

					Chemistry</a>
			</div>
			<div class="sub ma">
				<a href="/mathematics">
					<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" x="0px" y="0px" viewBox="0 0 144 144" style="enable-background:new 0 0 144 144;" xml:space="preserve">
					<style type="text/css">
						.ma0{fill:#299B3E;}
						.ma1{fill:#2FBB4F;}
						.ma2{opacity:0.9;fill:url(#SVGID_1_);}
						.ma3{fill:#FFFFFF;}
					</style>
					<polygon class="ma0" points="128.6,44.5 128.6,107.5 92.2,128.5 88.5,130.6 74,139 19.4,107.5 19.4,44.5 74,13 "/>
					<polygon class="ma1" points="20,42 20,102 72,132 124,102 124,42 72,12 "/>
					<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="50.5332" y1="58.2702" x2="183.9985" y2="163.0599">
						<stop  offset="0" style="stop-color:#000000;stop-opacity:0.3"/>
						<stop  offset="1" style="stop-color:#FFFFFF;stop-opacity:0.5"/>
					</linearGradient>
					<path class="ma2" d="M128.6,72.7v34.8l-36.3,21L74,139L38.4,95.2l12-30.6l7.8,1.3l11,8.3c0,0,13.9-10.7,14.3-11.8
						c0.4-1.1,4.9-5.3,5.2-5.2c11.7,7.7,8.6-9.6,6.3-10.6l10.6-7.4L128.6,72.7z"/>
					<g>
						<path class="ma3" d="M88.4,95.2l-0.2-25.5L76.1,90.2h-8.3L55.6,70.6v24.6H38.4v-56h15.5L72.2,69l17.8-29.8h15.5l0.2,56H88.4z"/>
					</g>
					</svg>
					Maths</a>
			</div>
			<div class="sub en">
				<a href="/english">
					<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" x="0px" y="0px"
						 viewBox="0 0 144 144" style="enable-background:new 0 0 144 144;" xml:space="preserve">
					<style type="text/css">
						.st0{fill:#24292D;}
						.st1{fill:#2B3137;}
						.st2{opacity:0.9;fill:url(#SVGID_1_);}
						.st3{opacity:0.96;fill:#FFFFFF;}
					</style>
					<polygon class="st0" points="128.6,44.5 128.6,107.5 92.2,128.5 88.5,130.6 74,139 19.4,107.5 19.4,44.5 74,13 "/>
					<polygon class="st1" points="20,42 20,102 72,132 124,102 124,42 72,12 "/>
					<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="48.3241" y1="60.6319" x2="182.1953" y2="165.7403">
						<stop  offset="0" style="stop-color:#FFFFFF;stop-opacity:0.1"/>
						<stop  offset="1" style="stop-color:#000000;stop-opacity:0.3"/>
					</linearGradient>
					<path class="st2" d="M128.6,72.7v34.8l-36.3,21L74,139L49.6,95.2l0.8-30.6l7.8,1.3l4.1-16.9c0,0,4.4-0.3,4.7-1.3
						c0.4-1.1,11.5-2.1,11.2-2.1c-0.2-0.1-3.8-1.7-6.1-2.8l22.9-3.5L128.6,72.7z"/>
					<g>
						<path class="st3" d="M96.2,81v14.2H49.6v-56h45.5v14.2h-27V60h23.7v13.6H68.2V81H96.2z"/>
					</g>
					</svg>

					English</a>
			</div>
			<div class="sub close-ham">
				<img src="https://img.icons8.com/fluent/48/000000/close-window.png" width="30px" align="center">
			</div>
		</div>
	</header>

	<main class="main-container" style="min-height: 0px;">
        <div class="heading">
            <p id="test">XMEMO <span id="theme-changer" class="inline-btn" onclick="switch_theme()">Change Theme</span></p>
            <div></div>
        </div>
		{{ html_string | safe }}
	</main>

	<footer>
		<div class="footer">
			<p class="noselect">¬© Made with ‚ù§ by Sujal Singh üë®‚ÄçüöÄüöÄ</p>
			<p class="contrib noselect"> Want to contribute? <a href="https://github.com/sujaldev/xmemo" target="blank">
				<svg class="githublogo" fill="" height="22" viewBox="0 0 16 16" version="1.1" width="22" aria-hidden="true">
					<path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
					</path></svg>
			</a></p>
		</div>
	</footer>

	<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script>

	<script type="text/javascript">

		function switch_theme(element){
			current_theme = $("#theme_css").attr("href")

			if (current_theme == "/static/css/dark-theme.css"){
				theme_to_set = "/static/css/light-theme.css";
			} else if (current_theme == "/static/css/light-theme.css"){
				theme_to_set = "/static/css/dark-theme.css";
			}


		    $.post('/switch-theme/', {
		        csrfmiddlewaretoken: "{{ csrf_token }}",
		        theme: theme_to_set
		    }, function(response){
		        // location.reload();
		        $('#theme_css').attr("href", theme_to_set);
			});
		}

		function update_correct_val(element) {
			parent_id = $(element).parent().attr("id");
			unique_id_num = parent_id.slice(parent_id.length-1, parent_id.length);
			question_text = $(element).parent().siblings('.question').children('p').html();

			$.post('/update-review/', {
				csrfmiddlewaretoken: "{{ csrf_token }}",
				question: question_text,
				unique_id: unique_id_num,
				val_type: "correct_val"
			}, function(response){
				indicator_elem = $(`#${parent_id}correct_indicator`);
				current_indicator = parseInt(indicator_elem.html(), 10);
				current_indicator += 1;
				indicator_elem.html(`${current_indicator} found this answer to be incorrect.`);
			});
		}

		function update_incorrect_val(element) {
			parent_id = $(element).parent().attr("id");
			unique_id_num = parent_id.slice(parent_id.length-1, parent_id.length);
			question_text = $(element).parent().siblings('.question').children('p').html();

			$.post('/update-review/', {
				csrfmiddlewaretoken: "{{ csrf_token }}",
				question: question_text,
				unique_id: unique_id_num,
				val_type: "wrong_val"
			}, function(response){
				indicator_elem = $(`#${parent_id}wrong_indicator`);
				current_indicator = parseInt(indicator_elem.html(), 10);
				current_indicator += 1;
				indicator_elem.html(`${current_indicator} found this answer to be incorrect.`);

			});
		};
	</script>
	<script type="text/javascript">
		ham = document.getElementsByClassName('ham-menu')[0];
		open_btn = document.getElementsByClassName('logo')[0];
		close_btn = document.getElementsByClassName('sub close-ham')[0];

		open_btn.onclick = function(){
			ham.setAttribute('class', 'ham-menu ham-active');
		};

		close_btn.onclick = function(){
			ham.setAttribute('class', 'ham-menu');
		};
	</script>
    <script type="text/javascript">
	        /* PrismJS 1.23.0
			https://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript+markdown+python */
			/// <reference lib="WebWorker"/>

			var _self = (typeof window !== 'undefined')
				? window   // if in browser
				: (
					(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
					? self // if in worker
					: {}   // if in node js
				);

			/**
			 * Prism: Lightweight, robust, elegant syntax highlighting
			 *
			 * @license MIT <https://opensource.org/licenses/MIT>
			 * @author Lea Verou <https://lea.verou.me>
			 * @namespace
			 * @public
			 */
			var Prism = (function (_self){

			// Private helper vars
			var lang = /\blang(?:uage)?-([\w-]+)\b/i;
			var uniqueId = 0;

			// The grammar object for plaintext
			var plainTextGrammar = {};


			var _ = {
				/**
				 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
				 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
				 * additional languages or plugins yourself.
				 *
				 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
				 *
				 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
				 * empty Prism object into the global scope before loading the Prism script like this:
				 *
				 * ```js
				 * window.Prism = window.Prism || {};
				 * Prism.manual = true;
				 * // add a new <script> to load Prism's script
				 * ```
				 *
				 * @default false
				 * @type {boolean}
				 * @memberof Prism
				 * @public
				 */
				manual: _self.Prism && _self.Prism.manual,
				disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

				/**
				 * A namespace for utility methods.
				 *
				 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
				 * change or disappear at any time.
				 *
				 * @namespace
				 * @memberof Prism
				 */
				util: {
					encode: function encode(tokens) {
						if (tokens instanceof Token) {
							return new Token(tokens.type, encode(tokens.content), tokens.alias);
						} else if (Array.isArray(tokens)) {
							return tokens.map(encode);
						} else {
							return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
						}
					},

					/**
					 * Returns the name of the type of the given value.
					 *
					 * @param {any} o
					 * @returns {string}
					 * @example
					 * type(null)      === 'Null'
					 * type(undefined) === 'Undefined'
					 * type(123)       === 'Number'
					 * type('foo')     === 'String'
					 * type(true)      === 'Boolean'
					 * type([1, 2])    === 'Array'
					 * type({})        === 'Object'
					 * type(String)    === 'Function'
					 * type(/abc+/)    === 'RegExp'
					 */
					type: function (o) {
						return Object.prototype.toString.call(o).slice(8, -1);
					},

					/**
					 * Returns a unique number for the given object. Later calls will still return the same number.
					 *
					 * @param {Object} obj
					 * @returns {number}
					 */
					objId: function (obj) {
						if (!obj['__id']) {
							Object.defineProperty(obj, '__id', { value: ++uniqueId });
						}
						return obj['__id'];
					},

					/**
					 * Creates a deep clone of the given object.
					 *
					 * The main intended use of this function is to clone language definitions.
					 *
					 * @param {T} o
					 * @param {Record<number, any>} [visited]
					 * @returns {T}
					 * @template T
					 */
					clone: function deepClone(o, visited) {
						visited = visited || {};

						var clone, id;
						switch (_.util.type(o)) {
							case 'Object':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone = /** @type {Record<string, any>} */ ({});
								visited[id] = clone;

								for (var key in o) {
									if (o.hasOwnProperty(key)) {
										clone[key] = deepClone(o[key], visited);
									}
								}

								return /** @type {any} */ (clone);

							case 'Array':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone = [];
								visited[id] = clone;

								(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
									clone[i] = deepClone(v, visited);
								});

								return /** @type {any} */ (clone);

							default:
								return o;
						}
					},

					/**
					 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
					 *
					 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
					 *
					 * @param {Element} element
					 * @returns {string}
					 */
					getLanguage: function (element) {
						while (element && !lang.test(element.className)) {
							element = element.parentElement;
						}
						if (element) {
							return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
						}
						return 'none';
					},

					/**
					 * Returns the script element that is currently executing.
					 *
					 * This does __not__ work for line script element.
					 *
					 * @returns {HTMLScriptElement | null}
					 */
					currentScript: function () {
						if (typeof document === 'undefined') {
							return null;
						}
						if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
							return /** @type {any} */ (document.currentScript);
						}

						// IE11 workaround
						// we'll get the src of the current script by parsing IE11's error stack trace
						// this will not work for inline scripts

						try {
							throw new Error();
						} catch (err) {
							// Get file src url from stack. Specifically works with the format of stack traces in IE.
							// A stack will look like this:
							//
							// Error
							//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
							//    at Global code (http://localhost/components/prism-core.js:606:1)

							var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
							if (src) {
								var scripts = document.getElementsByTagName('script');
								for (var i in scripts) {
									if (scripts[i].src == src) {
										return scripts[i];
									}
								}
							}
							return null;
						}
					},

					/**
					 * Returns whether a given class is active for `element`.
					 *
					 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
					 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
					 * given class is just the given class with a `no-` prefix.
					 *
					 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
					 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
					 * ancestors have the given class or the negated version of it, then the default activation will be returned.
					 *
					 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
					 * version of it, the class is considered active.
					 *
					 * @param {Element} element
					 * @param {string} className
					 * @param {boolean} [defaultActivation=false]
					 * @returns {boolean}
					 */
					isActive: function (element, className, defaultActivation) {
						var no = 'no-' + className;

						while (element) {
							var classList = element.classList;
							if (classList.contains(className)) {
								return true;
							}
							if (classList.contains(no)) {
								return false;
							}
							element = element.parentElement;
						}
						return !!defaultActivation;
					}
				},

				/**
				 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
				 *
				 * @namespace
				 * @memberof Prism
				 * @public
				 */
				languages: {
					/**
					 * The grammar for plain, unformatted text.
					 */
					plain: plainTextGrammar,
					plaintext: plainTextGrammar,
					text: plainTextGrammar,
					txt: plainTextGrammar,

					/**
					 * Creates a deep copy of the language with the given id and appends the given tokens.
					 *
					 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
					 * will be overwritten at its original position.
					 *
					 * ## Best practices
					 *
					 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
					 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
					 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
					 *
					 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
					 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
					 *
					 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
					 * @param {Grammar} redef The new tokens to append.
					 * @returns {Grammar} The new language created.
					 * @public
					 * @example
					 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
					 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
					 *     // at its original position
					 *     'comment': { ... },
					 *     // CSS doesn't have a 'color' token, so this token will be appended
					 *     'color': /\b(?:red|green|blue)\b/
					 * });
					 */
					extend: function (id, redef) {
						var lang = _.util.clone(_.languages[id]);

						for (var key in redef) {
							lang[key] = redef[key];
						}

						return lang;
					},

					/**
					 * Inserts tokens _before_ another token in a language definition or any other grammar.
					 *
					 * ## Usage
					 *
					 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
					 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
					 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
					 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
					 * this:
					 *
					 * ```js
					 * Prism.languages.markup.style = {
					 *     // token
					 * };
					 * ```
					 *
					 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
					 * before existing tokens. For the CSS example above, you would use it like this:
					 *
					 * ```js
					 * Prism.languages.insertBefore('markup', 'cdata', {
					 *     'style': {
					 *         // token
					 *     }
					 * });
					 * ```
					 *
					 * ## Special cases
					 *
					 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
					 * will be ignored.
					 *
					 * This behavior can be used to insert tokens after `before`:
					 *
					 * ```js
					 * Prism.languages.insertBefore('markup', 'comment', {
					 *     'comment': Prism.languages.markup.comment,
					 *     // tokens after 'comment'
					 * });
					 * ```
					 *
					 * ## Limitations
					 *
					 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
					 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
					 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
					 * deleting properties which is necessary to insert at arbitrary positions.
					 *
					 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
					 * Instead, it will create a new object and replace all references to the target object with the new one. This
					 * can be done without temporarily deleting properties, so the iteration order is well-defined.
					 *
					 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
					 * you hold the target object in a variable, then the value of the variable will not change.
					 *
					 * ```js
					 * var oldMarkup = Prism.languages.markup;
					 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
					 *
					 * assert(oldMarkup !== Prism.languages.markup);
					 * assert(newMarkup === Prism.languages.markup);
					 * ```
					 *
					 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
					 * object to be modified.
					 * @param {string} before The key to insert before.
					 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
					 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
					 * object to be modified.
					 *
					 * Defaults to `Prism.languages`.
					 * @returns {Grammar} The new grammar object.
					 * @public
					 */
					insertBefore: function (inside, before, insert, root) {
						root = root || /** @type {any} */ (_.languages);
						var grammar = root[inside];
						/** @type {Grammar} */
						var ret = {};

						for (var token in grammar) {
							if (grammar.hasOwnProperty(token)) {

								if (token == before) {
									for (var newToken in insert) {
										if (insert.hasOwnProperty(newToken)) {
											ret[newToken] = insert[newToken];
										}
									}
								}

								// Do not insert token which also occur in insert. See #1525
								if (!insert.hasOwnProperty(token)) {
									ret[token] = grammar[token];
								}
							}
						}

						var old = root[inside];
						root[inside] = ret;

						// Update references in other language definitions
						_.languages.DFS(_.languages, function(key, value) {
							if (value === old && key != inside) {
								this[key] = ret;
							}
						});

						return ret;
					},

					// Traverse a language definition with Depth First Search
					DFS: function DFS(o, callback, type, visited) {
						visited = visited || {};

						var objId = _.util.objId;

						for (var i in o) {
							if (o.hasOwnProperty(i)) {
								callback.call(o, i, o[i], type || i);

								var property = o[i],
								    propertyType = _.util.type(property);

								if (propertyType === 'Object' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, null, visited);
								}
								else if (propertyType === 'Array' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, i, visited);
								}
							}
						}
					}
				},

				plugins: {},

				/**
				 * This is the most high-level function in Prism‚Äôs API.
				 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
				 * each one of them.
				 *
				 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
				 *
				 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
				 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
				 * @memberof Prism
				 * @public
				 */
				highlightAll: function(async, callback) {
					_.highlightAllUnder(document, async, callback);
				},

				/**
				 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
				 * {@link Prism.highlightElement} on each one of them.
				 *
				 * The following hooks will be run:
				 * 1. `before-highlightall`
				 * 2. `before-all-elements-highlight`
				 * 3. All hooks of {@link Prism.highlightElement} for each element.
				 *
				 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
				 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
				 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
				 * @memberof Prism
				 * @public
				 */
				highlightAllUnder: function(container, async, callback) {
					var env = {
						callback: callback,
						container: container,
						selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
					};

					_.hooks.run('before-highlightall', env);

					env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

					_.hooks.run('before-all-elements-highlight', env);

					for (var i = 0, element; element = env.elements[i++];) {
						_.highlightElement(element, async === true, env.callback);
					}
				},

				/**
				 * Highlights the code inside a single element.
				 *
				 * The following hooks will be run:
				 * 1. `before-sanity-check`
				 * 2. `before-highlight`
				 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
				 * 4. `before-insert`
				 * 5. `after-highlight`
				 * 6. `complete`
				 *
				 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
				 * the element's language.
				 *
				 * @param {Element} element The element containing the code.
				 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
				 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
				 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
				 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
				 *
				 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
				 * asynchronous highlighting to work. You can build your own bundle on the
				 * [Download page](https://prismjs.com/download.html).
				 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
				 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
				 * @memberof Prism
				 * @public
				 */
				highlightElement: function(element, async, callback) {
					// Find language
					var language = _.util.getLanguage(element);
					var grammar = _.languages[language];

					// Set language on the element, if not present
					element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

					// Set language on the parent, for styling
					var parent = element.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre') {
						parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
					}

					var code = element.textContent;

					var env = {
						element: element,
						language: language,
						grammar: grammar,
						code: code
					};

					function insertHighlightedCode(highlightedCode) {
						env.highlightedCode = highlightedCode;

						_.hooks.run('before-insert', env);

						env.element.innerHTML = env.highlightedCode;

						_.hooks.run('after-highlight', env);
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
					}

					_.hooks.run('before-sanity-check', env);

					// plugins may change/add the parent/element
					parent = env.element.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
						parent.setAttribute('tabindex', '0');
					}

					if (!env.code) {
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
						return;
					}

					_.hooks.run('before-highlight', env);

					if (!env.grammar) {
						insertHighlightedCode(_.util.encode(env.code));
						return;
					}

					if (async && _self.Worker) {
						var worker = new Worker(_.filename);

						worker.onmessage = function(evt) {
							insertHighlightedCode(evt.data);
						};

						worker.postMessage(JSON.stringify({
							language: env.language,
							code: env.code,
							immediateClose: true
						}));
					}
					else {
						insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
					}
				},

				/**
				 * Low-level function, only use if you know what you‚Äôre doing. It accepts a string of text as input
				 * and the language definitions to use, and returns a string with the HTML produced.
				 *
				 * The following hooks will be run:
				 * 1. `before-tokenize`
				 * 2. `after-tokenize`
				 * 3. `wrap`: On each {@link Token}.
				 *
				 * @param {string} text A string with the code to be highlighted.
				 * @param {Grammar} grammar An object containing the tokens to use.
				 *
				 * Usually a language definition like `Prism.languages.markup`.
				 * @param {string} language The name of the language definition passed to `grammar`.
				 * @returns {string} The highlighted HTML.
				 * @memberof Prism
				 * @public
				 * @example
				 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
				 */
				highlight: function (text, grammar, language) {
					var env = {
						code: text,
						grammar: grammar,
						language: language
					};
					_.hooks.run('before-tokenize', env);
					env.tokens = _.tokenize(env.code, env.grammar);
					_.hooks.run('after-tokenize', env);
					return Token.stringify(_.util.encode(env.tokens), env.language);
				},

				/**
				 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
				 * and the language definitions to use, and returns an array with the tokenized code.
				 *
				 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
				 *
				 * This method could be useful in other contexts as well, as a very crude parser.
				 *
				 * @param {string} text A string with the code to be highlighted.
				 * @param {Grammar} grammar An object containing the tokens to use.
				 *
				 * Usually a language definition like `Prism.languages.markup`.
				 * @returns {TokenStream} An array of strings and tokens, a token stream.
				 * @memberof Prism
				 * @public
				 * @example
				 * let code = `var foo = 0;`;
				 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
				 * tokens.forEach(token => {
				 *     if (token instanceof Prism.Token && token.type === 'number') {
				 *         console.log(`Found numeric literal: ${token.content}`);
				 *     }
				 * });
				 */
				tokenize: function(text, grammar) {
					var rest = grammar.rest;
					if (rest) {
						for (var token in rest) {
							grammar[token] = rest[token];
						}

						delete grammar.rest;
					}

					var tokenList = new LinkedList();
					addAfter(tokenList, tokenList.head, text);

					matchGrammar(text, tokenList, grammar, tokenList.head, 0);

					return toArray(tokenList);
				},

				/**
				 * @namespace
				 * @memberof Prism
				 * @public
				 */
				hooks: {
					all: {},

					/**
					 * Adds the given callback to the list of callbacks for the given hook.
					 *
					 * The callback will be invoked when the hook it is registered for is run.
					 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
					 *
					 * One callback function can be registered to multiple hooks and the same hook multiple times.
					 *
					 * @param {string} name The name of the hook.
					 * @param {HookCallback} callback The callback function which is given environment variables.
					 * @public
					 */
					add: function (name, callback) {
						var hooks = _.hooks.all;

						hooks[name] = hooks[name] || [];

						hooks[name].push(callback);
					},

					/**
					 * Runs a hook invoking all registered callbacks with the given environment variables.
					 *
					 * Callbacks will be invoked synchronously and in the order in which they were registered.
					 *
					 * @param {string} name The name of the hook.
					 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
					 * @public
					 */
					run: function (name, env) {
						var callbacks = _.hooks.all[name];

						if (!callbacks || !callbacks.length) {
							return;
						}

						for (var i=0, callback; callback = callbacks[i++];) {
							callback(env);
						}
					}
				},

				Token: Token
			};
			_self.Prism = _;


			// Typescript note:
			// The following can be used to import the Token type in JSDoc:
			//
			//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

			/**
			 * Creates a new token.
			 *
			 * @param {string} type See {@link Token#type type}
			 * @param {string | TokenStream} content See {@link Token#content content}
			 * @param {string|string[]} [alias] The alias(es) of the token.
			 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
			 * @class
			 * @global
			 * @public
			 */
			function Token(type, content, alias, matchedStr) {
				/**
				 * The type of the token.
				 *
				 * This is usually the key of a pattern in a {@link Grammar}.
				 *
				 * @type {string}
				 * @see GrammarToken
				 * @public
				 */
				this.type = type;
				/**
				 * The strings or tokens contained by this token.
				 *
				 * This will be a token stream if the pattern matched also defined an `inside` grammar.
				 *
				 * @type {string | TokenStream}
				 * @public
				 */
				this.content = content;
				/**
				 * The alias(es) of the token.
				 *
				 * @type {string|string[]}
				 * @see GrammarToken
				 * @public
				 */
				this.alias = alias;
				// Copy of the full string this token was created from
				this.length = (matchedStr || '').length | 0;
			}

			/**
			 * A token stream is an array of strings and {@link Token Token} objects.
			 *
			 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
			 * them.
			 *
			 * 1. No adjacent strings.
			 * 2. No empty strings.
			 *
			 *    The only exception here is the token stream that only contains the empty string and nothing else.
			 *
			 * @typedef {Array<string | Token>} TokenStream
			 * @global
			 * @public
			 */

			/**
			 * Converts the given token or token stream to an HTML representation.
			 *
			 * The following hooks will be run:
			 * 1. `wrap`: On each {@link Token}.
			 *
			 * @param {string | Token | TokenStream} o The token or token stream to be converted.
			 * @param {string} language The name of current language.
			 * @returns {string} The HTML representation of the token or token stream.
			 * @memberof Token
			 * @static
			 */
			Token.stringify = function stringify(o, language) {
				if (typeof o == 'string') {
					return o;
				}
				if (Array.isArray(o)) {
					var s = '';
					o.forEach(function (e) {
						s += stringify(e, language);
					});
					return s;
				}

				var env = {
					type: o.type,
					content: stringify(o.content, language),
					tag: 'span',
					classes: ['token', o.type],
					attributes: {},
					language: language
				};

				var aliases = o.alias;
				if (aliases) {
					if (Array.isArray(aliases)) {
						Array.prototype.push.apply(env.classes, aliases);
					} else {
						env.classes.push(aliases);
					}
				}

				_.hooks.run('wrap', env);

				var attributes = '';
				for (var name in env.attributes) {
					attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
				}

				return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
			};

			/**
			 * @param {RegExp} pattern
			 * @param {number} pos
			 * @param {string} text
			 * @param {boolean} lookbehind
			 * @returns {RegExpExecArray | null}
			 */
			function matchPattern(pattern, pos, text, lookbehind) {
				pattern.lastIndex = pos;
				var match = pattern.exec(text);
				if (match && lookbehind && match[1]) {
					// change the match to remove the text matched by the Prism lookbehind group
					var lookbehindLength = match[1].length;
					match.index += lookbehindLength;
					match[0] = match[0].slice(lookbehindLength);
				}
				return match;
			}

			/**
			 * @param {string} text
			 * @param {LinkedList<string | Token>} tokenList
			 * @param {any} grammar
			 * @param {LinkedListNode<string | Token>} startNode
			 * @param {number} startPos
			 * @param {RematchOptions} [rematch]
			 * @returns {void}
			 * @private
			 *
			 * @typedef RematchOptions
			 * @property {string} cause
			 * @property {number} reach
			 */
			function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
				for (var token in grammar) {
					if (!grammar.hasOwnProperty(token) || !grammar[token]) {
						continue;
					}

					var patterns = grammar[token];
					patterns = Array.isArray(patterns) ? patterns : [patterns];

					for (var j = 0; j < patterns.length; ++j) {
						if (rematch && rematch.cause == token + ',' + j) {
							return;
						}

						var patternObj = patterns[j],
							inside = patternObj.inside,
							lookbehind = !!patternObj.lookbehind,
							greedy = !!patternObj.greedy,
							alias = patternObj.alias;

						if (greedy && !patternObj.pattern.global) {
							// Without the global flag, lastIndex won't work
							var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
							patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
						}

						/** @type {RegExp} */
						var pattern = patternObj.pattern || patternObj;

						for ( // iterate the token list and keep track of the current token/string position
							var currentNode = startNode.next, pos = startPos;
							currentNode !== tokenList.tail;
							pos += currentNode.value.length, currentNode = currentNode.next
						) {

							if (rematch && pos >= rematch.reach) {
								break;
							}

							var str = currentNode.value;

							if (tokenList.length > text.length) {
								// Something went terribly wrong, ABORT, ABORT!
								return;
							}

							if (str instanceof Token) {
								continue;
							}

							var removeCount = 1; // this is the to parameter of removeBetween
							var match;

							if (greedy) {
								match = matchPattern(pattern, pos, text, lookbehind);
								if (!match) {
									break;
								}

								var from = match.index;
								var to = match.index + match[0].length;
								var p = pos;

								// find the node that contains the match
								p += currentNode.value.length;
								while (from >= p) {
									currentNode = currentNode.next;
									p += currentNode.value.length;
								}
								// adjust pos (and p)
								p -= currentNode.value.length;
								pos = p;

								// the current node is a Token, then the match starts inside another Token, which is invalid
								if (currentNode.value instanceof Token) {
									continue;
								}

								// find the last node which is affected by this match
								for (
									var k = currentNode;
									k !== tokenList.tail && (p < to || typeof k.value === 'string');
									k = k.next
								) {
									removeCount++;
									p += k.value.length;
								}
								removeCount--;

								// replace with the new match
								str = text.slice(pos, p);
								match.index -= pos;
							} else {
								match = matchPattern(pattern, 0, str, lookbehind);
								if (!match) {
									continue;
								}
							}

							var from = match.index,
								matchStr = match[0],
								before = str.slice(0, from),
								after = str.slice(from + matchStr.length);

							var reach = pos + str.length;
							if (rematch && reach > rematch.reach) {
								rematch.reach = reach;
							}

							var removeFrom = currentNode.prev;

							if (before) {
								removeFrom = addAfter(tokenList, removeFrom, before);
								pos += before.length;
							}

							removeRange(tokenList, removeFrom, removeCount);

							var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
							currentNode = addAfter(tokenList, removeFrom, wrapped);

							if (after) {
								addAfter(tokenList, currentNode, after);
							}

							if (removeCount > 1) {
								// at least one Token object was removed, so we have to do some rematching
								// this can only happen if the current pattern is greedy

								/** @type {RematchOptions} */
								var nestedRematch = {
									cause: token + ',' + j,
									reach: reach
								};
								matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

								// the reach might have been extended because of the rematching
								if (rematch && nestedRematch.reach > rematch.reach) {
									rematch.reach = nestedRematch.reach;
								}
							}
						}
					}
				}
			}

			/**
			 * @typedef LinkedListNode
			 * @property {T} value
			 * @property {LinkedListNode<T> | null} prev The previous node.
			 * @property {LinkedListNode<T> | null} next The next node.
			 * @template T
			 * @private
			 */

			/**
			 * @template T
			 * @private
			 */
			function LinkedList() {
				/** @type {LinkedListNode<T>} */
				var head = { value: null, prev: null, next: null };
				/** @type {LinkedListNode<T>} */
				var tail = { value: null, prev: head, next: null };
				head.next = tail;

				/** @type {LinkedListNode<T>} */
				this.head = head;
				/** @type {LinkedListNode<T>} */
				this.tail = tail;
				this.length = 0;
			}

			/**
			 * Adds a new node with the given value to the list.
			 * @param {LinkedList<T>} list
			 * @param {LinkedListNode<T>} node
			 * @param {T} value
			 * @returns {LinkedListNode<T>} The added node.
			 * @template T
			 */
			function addAfter(list, node, value) {
				// assumes that node != list.tail && values.length >= 0
				var next = node.next;

				var newNode = { value: value, prev: node, next: next };
				node.next = newNode;
				next.prev = newNode;
				list.length++;

				return newNode;
			}
			/**
			 * Removes `count` nodes after the given node. The given node will not be removed.
			 * @param {LinkedList<T>} list
			 * @param {LinkedListNode<T>} node
			 * @param {number} count
			 * @template T
			 */
			function removeRange(list, node, count) {
				var next = node.next;
				for (var i = 0; i < count && next !== list.tail; i++) {
					next = next.next;
				}
				node.next = next;
				next.prev = node;
				list.length -= i;
			}
			/**
			 * @param {LinkedList<T>} list
			 * @returns {T[]}
			 * @template T
			 */
			function toArray(list) {
				var array = [];
				var node = list.head.next;
				while (node !== list.tail) {
					array.push(node.value);
					node = node.next;
				}
				return array;
			}


			if (!_self.document) {
				if (!_self.addEventListener) {
					// in Node.js
					return _;
				}

				if (!_.disableWorkerMessageHandler) {
					// In worker
					_self.addEventListener('message', function (evt) {
						var message = JSON.parse(evt.data),
							lang = message.language,
							code = message.code,
							immediateClose = message.immediateClose;

						_self.postMessage(_.highlight(code, _.languages[lang], lang));
						if (immediateClose) {
							_self.close();
						}
					}, false);
				}

				return _;
			}

			// Get current script and highlight
			var script = _.util.currentScript();

			if (script) {
				_.filename = script.src;

				if (script.hasAttribute('data-manual')) {
					_.manual = true;
				}
			}

			function highlightAutomaticallyCallback() {
				if (!_.manual) {
					_.highlightAll();
				}
			}

			if (!_.manual) {
				// If the document state is "loading", then we'll use DOMContentLoaded.
				// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
				// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
				// might take longer one animation frame to execute which can create a race condition where only some plugins have
				// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
				// See https://github.com/PrismJS/prism/issues/2102
				var readyState = document.readyState;
				if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
					document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
				} else {
					if (window.requestAnimationFrame) {
						window.requestAnimationFrame(highlightAutomaticallyCallback);
					} else {
						window.setTimeout(highlightAutomaticallyCallback, 16);
					}
				}
			}

			return _;

			})(_self);

			if (typeof module !== 'undefined' && module.exports) {
				module.exports = Prism;
			}

			// hack for components to work correctly in node.js
			if (typeof global !== 'undefined') {
				global.Prism = Prism;
			}

			// some additional documentation/types

			/**
			 * The expansion of a simple `RegExp` literal to support additional properties.
			 *
			 * @typedef GrammarToken
			 * @property {RegExp} pattern The regular expression of the token.
			 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
			 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
			 * @property {boolean} [greedy=false] Whether the token is greedy.
			 * @property {string|string[]} [alias] An optional alias or list of aliases.
			 * @property {Grammar} [inside] The nested grammar of this token.
			 *
			 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
			 *
			 * This can be used to make nested and even recursive language definitions.
			 *
			 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
			 * each another.
			 * @global
			 * @public
			*/

			/**
			 * @typedef Grammar
			 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
			 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
			 * @global
			 * @public
			 */

			/**
			 * A function which will invoked after an element was successfully highlighted.
			 *
			 * @callback HighlightCallback
			 * @param {Element} element The element successfully highlighted.
			 * @returns {void}
			 * @global
			 * @public
			*/

			/**
			 * @callback HookCallback
			 * @param {Object<string, any>} env The environment variables of the hook.
			 * @returns {void}
			 * @global
			 * @public
			 */
			;
			Prism.languages.markup = {
				'comment': /<!--[\s\S]*?-->/,
				'prolog': /<\?[\s\S]+?\?>/,
				'doctype': {
					// https://www.w3.org/TR/xml/#NT-doctypedecl
					pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
					greedy: true,
					inside: {
						'internal-subset': {
							pattern: /(\[)[\s\S]+(?=\]>$)/,
							lookbehind: true,
							greedy: true,
							inside: null // see below
						},
						'string': {
							pattern: /"[^"]*"|'[^']*'/,
							greedy: true
						},
						'punctuation': /^<!|>$|[[\]]/,
						'doctype-tag': /^DOCTYPE/,
						'name': /[^\s<>'"]+/
					}
				},
				'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
				'tag': {
					pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
					greedy: true,
					inside: {
						'tag': {
							pattern: /^<\/?[^\s>\/]+/,
							inside: {
								'punctuation': /^<\/?/,
								'namespace': /^[^\s>\/:]+:/
							}
						},
						'special-attr': [],
						'attr-value': {
							pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
							inside: {
								'punctuation': [
									{
										pattern: /^=/,
										alias: 'attr-equals'
									},
									/"|'/
								]
							}
						},
						'punctuation': /\/?>/,
						'attr-name': {
							pattern: /[^\s>\/]+/,
							inside: {
								'namespace': /^[^\s>\/:]+:/
							}
						}

					}
				},
				'entity': [
					{
						pattern: /&[\da-z]{1,8};/i,
						alias: 'named-entity'
					},
					/&#x?[\da-f]{1,8};/i
				]
			};

			Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
				Prism.languages.markup['entity'];
			Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

			// Plugin to make entity title show the real entity, idea by Roman Komarov
			Prism.hooks.add('wrap', function (env) {

				if (env.type === 'entity') {
					env.attributes['title'] = env.content.replace(/&amp;/, '&');
				}
			});

			Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
				/**
				 * Adds an inlined language to markup.
				 *
				 * An example of an inlined language is CSS with `<style>` tags.
				 *
				 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
				 * case insensitive.
				 * @param {string} lang The language key.
				 * @example
				 * addInlined('style', 'css');
				 */
				value: function addInlined(tagName, lang) {
					var includedCdataInside = {};
					includedCdataInside['language-' + lang] = {
						pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
						lookbehind: true,
						inside: Prism.languages[lang]
					};
					includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

					var inside = {
						'included-cdata': {
							pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
							inside: includedCdataInside
						}
					};
					inside['language-' + lang] = {
						pattern: /[\s\S]+/,
						inside: Prism.languages[lang]
					};

					var def = {};
					def[tagName] = {
						pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
						lookbehind: true,
						greedy: true,
						inside: inside
					};

					Prism.languages.insertBefore('markup', 'cdata', def);
				}
			});
			Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
				/**
				 * Adds an pattern to highlight languages embedded in HTML attributes.
				 *
				 * An example of an inlined language is CSS with `style` attributes.
				 *
				 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
				 * case insensitive.
				 * @param {string} lang The language key.
				 * @example
				 * addAttribute('style', 'css');
				 */
				value: function (attrName, lang) {
					Prism.languages.markup.tag.inside['special-attr'].push({
						pattern: RegExp(
							/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
							'i'
						),
						lookbehind: true,
						inside: {
							'attr-name': /^[^\s=]+/,
							'attr-value': {
								pattern: /=[\s\S]+/,
								inside: {
									'value': {
										pattern: /(=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
										lookbehind: true,
										alias: [lang, 'language-' + lang],
										inside: Prism.languages[lang]
									},
									'punctuation': [
										{
											pattern: /^=/,
											alias: 'attr-equals'
										},
										/"|'/
									]
								}
							}
						}
					});
				}
			});

			Prism.languages.html = Prism.languages.markup;
			Prism.languages.mathml = Prism.languages.markup;
			Prism.languages.svg = Prism.languages.markup;

			Prism.languages.xml = Prism.languages.extend('markup', {});
			Prism.languages.ssml = Prism.languages.xml;
			Prism.languages.atom = Prism.languages.xml;
			Prism.languages.rss = Prism.languages.xml;

			(function (Prism) {

				var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;

				Prism.languages.css = {
					'comment': /\/\*[\s\S]*?\*\//,
					'atrule': {
						pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
						inside: {
							'rule': /^@[\w-]+/,
							'selector-function-argument': {
								pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
								lookbehind: true,
								alias: 'selector'
							},
							'keyword': {
								pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
								lookbehind: true
							}
							// See rest below
						}
					},
					'url': {
						// https://drafts.csswg.org/css-values-3/#urls
						pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
						greedy: true,
						inside: {
							'function': /^url/i,
							'punctuation': /^\(|\)$/,
							'string': {
								pattern: RegExp('^' + string.source + '$'),
								alias: 'url'
							}
						}
					},
					'selector': RegExp('[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
					'string': {
						pattern: string,
						greedy: true
					},
					'property': /(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
					'important': /!important\b/i,
					'function': /[-a-z0-9]+(?=\()/i,
					'punctuation': /[(){};:,]/
				};

				Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

				var markup = Prism.languages.markup;
				if (markup) {
					markup.tag.addInlined('style', 'css');
					markup.tag.addAttribute('style', 'css');
				}

			}(Prism));

			Prism.languages.clike = {
				'comment': [
					{
						pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				'string': {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				'class-name': {
					pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
					lookbehind: true,
					inside: {
						'punctuation': /[.\\]/
					}
				},
				'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
				'boolean': /\b(?:true|false)\b/,
				'function': /\w+(?=\()/,
				'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
				'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
				'punctuation': /[{}[\];(),.:]/
			};

			Prism.languages.javascript = Prism.languages.extend('clike', {
				'class-name': [
					Prism.languages.clike['class-name'],
					{
						pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
						lookbehind: true
					}
				],
				'keyword': [
					{
						pattern: /((?:^|})\s*)catch\b/,
						lookbehind: true
					},
					{
						pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
						lookbehind: true
					},
				],
				// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
				'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
				'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
				'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
			});

			Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

			Prism.languages.insertBefore('javascript', 'keyword', {
				'regex': {
					pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
					lookbehind: true,
					greedy: true,
					inside: {
						'regex-source': {
							pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
							lookbehind: true,
							alias: 'language-regex',
							inside: Prism.languages.regex
						},
						'regex-flags': /[a-z]+$/,
						'regex-delimiter': /^\/|\/$/
					}
				},
				// This must be declared before keyword because we use "function" inside the look-forward
				'function-variable': {
					pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
					alias: 'function'
				},
				'parameter': [
					{
						pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
						inside: Prism.languages.javascript
					},
					{
						pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
						lookbehind: true,
						inside: Prism.languages.javascript
					}
				],
				'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
			});

			Prism.languages.insertBefore('javascript', 'string', {
				'template-string': {
					pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
					greedy: true,
					inside: {
						'template-punctuation': {
							pattern: /^`|`$/,
							alias: 'string'
						},
						'interpolation': {
							pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
							lookbehind: true,
							inside: {
								'interpolation-punctuation': {
									pattern: /^\${|}$/,
									alias: 'punctuation'
								},
								rest: Prism.languages.javascript
							}
						},
						'string': /[\s\S]+/
					}
				}
			});

			if (Prism.languages.markup) {
				Prism.languages.markup.tag.addInlined('script', 'javascript');

				// add attribute support for all DOM events.
				// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
				Prism.languages.markup.tag.addAttribute(
					/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
					'javascript'
				);
			}

			Prism.languages.js = Prism.languages.javascript;

			(function (Prism) {

				// Allow only one line break
				var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?!\n|\r\n?))/.source;

				/**
				 * This function is intended for the creation of the bold or italic pattern.
				 *
				 * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
				 *
				 * _Note:_ Keep in mind that this adds a capturing group.
				 *
				 * @param {string} pattern
				 * @returns {RegExp}
				 */
				function createInline(pattern) {
					pattern = pattern.replace(/<inner>/g, function () { return inner; });
					return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
				}


				var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
				var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
				var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;


				Prism.languages.markdown = Prism.languages.extend('markup', {});
				Prism.languages.insertBefore('markdown', 'prolog', {
					'front-matter-block': {
						pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
						lookbehind: true,
						greedy: true,
						inside: {
							'punctuation': /^---|---$/,
							'font-matter': {
								pattern: /\S+(?:\s+\S+)*/,
								alias: ['yaml', 'language-yaml'],
								inside: Prism.languages.yaml
							}
						}
					},
					'blockquote': {
						// > ...
						pattern: /^>(?:[\t ]*>)*/m,
						alias: 'punctuation'
					},
					'table': {
						pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
						inside: {
							'table-data-rows': {
								pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
								lookbehind: true,
								inside: {
									'table-data': {
										pattern: RegExp(tableCell),
										inside: Prism.languages.markdown
									},
									'punctuation': /\|/
								}
							},
							'table-line': {
								pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
								lookbehind: true,
								inside: {
									'punctuation': /\||:?-{3,}:?/
								}
							},
							'table-header-row': {
								pattern: RegExp('^' + tableRow + '$'),
								inside: {
									'table-header': {
										pattern: RegExp(tableCell),
										alias: 'important',
										inside: Prism.languages.markdown
									},
									'punctuation': /\|/
								}
							}
						}
					},
					'code': [
						{
							// Prefixed by 4 spaces or 1 tab and preceded by an empty line
							pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
							lookbehind: true,
							alias: 'keyword'
						},
						{
							// `code`
							// ``code``
							pattern: /``.+?``|`[^`\r\n]+`/,
							alias: 'keyword'
						},
						{
							// ```optional language
							// code block
							// ```
							pattern: /^```[\s\S]*?^```$/m,
							greedy: true,
							inside: {
								'code-block': {
									pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
									lookbehind: true
								},
								'code-language': {
									pattern: /^(```).+/,
									lookbehind: true
								},
								'punctuation': /```/
							}
						}
					],
					'title': [
						{
							// title 1
							// =======

							// title 2
							// -------
							pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
							alias: 'important',
							inside: {
								punctuation: /==+$|--+$/
							}
						},
						{
							// # title 1
							// ###### title 6
							pattern: /(^\s*)#.+/m,
							lookbehind: true,
							alias: 'important',
							inside: {
								punctuation: /^#+|#+$/
							}
						}
					],
					'hr': {
						// ***
						// ---
						// * * *
						// -----------
						pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
						lookbehind: true,
						alias: 'punctuation'
					},
					'list': {
						// * item
						// + item
						// - item
						// 1. item
						pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
						lookbehind: true,
						alias: 'punctuation'
					},
					'url-reference': {
						// [id]: http://example.com "Optional title"
						// [id]: http://example.com 'Optional title'
						// [id]: http://example.com (Optional title)
						// [id]: <http://example.com> "Optional title"
						pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
						inside: {
							'variable': {
								pattern: /^(!?\[)[^\]]+/,
								lookbehind: true
							},
							'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
							'punctuation': /^[\[\]!:]|[<>]/
						},
						alias: 'url'
					},
					'bold': {
						// **strong**
						// __strong__

						// allow one nested instance of italic text using the same delimiter
						pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
						lookbehind: true,
						greedy: true,
						inside: {
							'content': {
								pattern: /(^..)[\s\S]+(?=..$)/,
								lookbehind: true,
								inside: {} // see below
							},
							'punctuation': /\*\*|__/
						}
					},
					'italic': {
						// *em*
						// _em_

						// allow one nested instance of bold text using the same delimiter
						pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
						lookbehind: true,
						greedy: true,
						inside: {
							'content': {
								pattern: /(^.)[\s\S]+(?=.$)/,
								lookbehind: true,
								inside: {} // see below
							},
							'punctuation': /[*_]/
						}
					},
					'strike': {
						// ~~strike through~~
						// ~strike~
						pattern: createInline(/(~~?)(?:(?!~)<inner>)+?\2/.source),
						lookbehind: true,
						greedy: true,
						inside: {
							'content': {
								pattern: /(^~~?)[\s\S]+(?=\1$)/,
								lookbehind: true,
								inside: {} // see below
							},
							'punctuation': /~~?/
						}
					},
					'url': {
						// [example](http://example.com "Optional title")
						// [example][id]
						// [example] [id]
						pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
						lookbehind: true,
						greedy: true,
						inside: {
							'operator': /^!/,
							'content': {
								pattern: /(^\[)[^\]]+(?=\])/,
								lookbehind: true,
								inside: {} // see below
							},
							'variable': {
								pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
								lookbehind: true
							},
							'url': {
								pattern: /(^\]\()[^\s)]+/,
								lookbehind: true
							},
							'string': {
								pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
								lookbehind: true
							}
						}
					}
				});

				['url', 'bold', 'italic', 'strike'].forEach(function (token) {
					['url', 'bold', 'italic', 'strike'].forEach(function (inside) {
						if (token !== inside) {
							Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
						}
					});
				});

				Prism.hooks.add('after-tokenize', function (env) {
					if (env.language !== 'markdown' && env.language !== 'md') {
						return;
					}

					function walkTokens(tokens) {
						if (!tokens || typeof tokens === 'string') {
							return;
						}

						for (var i = 0, l = tokens.length; i < l; i++) {
							var token = tokens[i];

							if (token.type !== 'code') {
								walkTokens(token.content);
								continue;
							}

							/*
							 * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
							 * is optional. But the grammar is defined so that there is only one case we have to handle:
							 *
							 * token.content = [
							 *     <span class="punctuation">```</span>,
							 *     <span class="code-language">xxxx</span>,
							 *     '\n', // exactly one new lines (\r or \n or \r\n)
							 *     <span class="code-block">...</span>,
							 *     '\n', // exactly one new lines again
							 *     <span class="punctuation">```</span>
							 * ];
							 */

							var codeLang = token.content[1];
							var codeBlock = token.content[3];

							if (codeLang && codeBlock &&
								codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
								typeof codeLang.content === 'string') {

								// this might be a language that Prism does not support

								// do some replacements to support C++, C#, and F#
								var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp')
								// only use the first word
								lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
								var alias = 'language-' + lang;

								// add alias
								if (!codeBlock.alias) {
									codeBlock.alias = [alias];
								} else if (typeof codeBlock.alias === 'string') {
									codeBlock.alias = [codeBlock.alias, alias];
								} else {
									codeBlock.alias.push(alias);
								}
							}
						}
					}

					walkTokens(env.tokens);
				});

				Prism.hooks.add('wrap', function (env) {
					if (env.type !== 'code-block') {
						return;
					}

					var codeLang = '';
					for (var i = 0, l = env.classes.length; i < l; i++) {
						var cls = env.classes[i];
						var match = /language-(.+)/.exec(cls);
						if (match) {
							codeLang = match[1];
							break;
						}
					}

					var grammar = Prism.languages[codeLang];

					if (!grammar) {
						if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
							var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
							env.attributes['id'] = id;

							Prism.plugins.autoloader.loadLanguages(codeLang, function () {
								var ele = document.getElementById(id);
								if (ele) {
									ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
								}
							});
						}
					} else {
						// get the textContent of the given env HTML
						var tempContainer = document.createElement('div');
						tempContainer.innerHTML = env.content;
						var code = tempContainer.textContent;

						env.content = Prism.highlight(code, grammar, codeLang);
					}
				});

				Prism.languages.md = Prism.languages.markdown;

			}(Prism));

			Prism.languages.python = {
				'comment': {
					pattern: /(^|[^\\])#.*/,
					lookbehind: true
				},
				'string-interpolation': {
					pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
					greedy: true,
					inside: {
						'interpolation': {
							// "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
							pattern: /((?:^|[^{])(?:{{)*){(?!{)(?:[^{}]|{(?!{)(?:[^{}]|{(?!{)(?:[^{}])+})+})+}/,
							lookbehind: true,
							inside: {
								'format-spec': {
									pattern: /(:)[^:(){}]+(?=}$)/,
									lookbehind: true
								},
								'conversion-option': {
									pattern: /![sra](?=[:}]$)/,
									alias: 'punctuation'
								},
								rest: null
							}
						},
						'string': /[\s\S]+/
					}
				},
				'triple-quoted-string': {
					pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]*?\1/i,
					greedy: true,
					alias: 'string'
				},
				'string': {
					pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
					greedy: true
				},
				'function': {
					pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
					lookbehind: true
				},
				'class-name': {
					pattern: /(\bclass\s+)\w+/i,
					lookbehind: true
				},
				'decorator': {
					pattern: /(^\s*)@\w+(?:\.\w+)*/im,
					lookbehind: true,
					alias: ['annotation', 'punctuation'],
					inside: {
						'punctuation': /\./
					}
				},
				'keyword': /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
				'builtin': /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
				'boolean': /\b(?:True|False|None)\b/,
				'number': /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
				'operator': /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
				'punctuation': /[{}[\];(),.:]/
			};

			Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;

			Prism.languages.py = Prism.languages.python;
    </script>
</body>